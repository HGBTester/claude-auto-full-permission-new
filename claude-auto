#!/usr/bin/env python3
"""
claude-auto: Cross-platform wrapper for Claude CLI that bypasses all permission prompts.

Uses Claude Code's native bypass mechanism instead of fragile keystroke simulation.
Works as root in containers by setting IS_SANDBOX=1 to unlock --dangerously-skip-permissions.

Supports both full interactive sessions and one-shot (-p) prompts.
"""

import argparse
import json
import os
import sys
import shutil
import subprocess
import platform

IS_WINDOWS = platform.system() == "Windows"

# ANSI colors
if IS_WINDOWS:
    try:
        import colorama
        colorama.init()
        GREEN = "\033[92m"
        YELLOW = "\033[93m"
        RED = "\033[91m"
        CYAN = "\033[96m"
        RESET = "\033[0m"
    except ImportError:
        GREEN = YELLOW = RED = CYAN = RESET = ""
else:
    GREEN = "\033[92m"
    YELLOW = "\033[93m"
    RED = "\033[91m"
    CYAN = "\033[96m"
    RESET = "\033[0m"


def print_status(msg, color=CYAN):
    sys.stderr.write(f"{color}[claude-auto]{RESET} {msg}\n")
    sys.stderr.flush()


def find_claude():
    """Find claude executable in the system."""
    names = ["claude", "claude.exe"] if IS_WINDOWS else ["claude"]

    for name in names:
        path = shutil.which(name)
        if path:
            return path

    if IS_WINDOWS:
        common_paths = [
            os.path.expandvars(r"%LOCALAPPDATA%\Programs\claude\claude.exe"),
            os.path.expandvars(r"%APPDATA%\npm\claude.cmd"),
            os.path.expandvars(r"%APPDATA%\npm\claude"),
            os.path.expanduser(r"~\.claude\claude.exe"),
            r"C:\Program Files\claude\claude.exe",
            r"C:\Program Files (x86)\claude\claude.exe",
        ]
    else:
        common_paths = [
            "/usr/local/bin/claude",
            "/usr/bin/claude",
            os.path.expanduser("~/.local/bin/claude"),
            os.path.expanduser("~/.npm-global/bin/claude"),
            "/opt/claude/claude",
            os.path.expanduser("~/.claude/claude"),
        ]

    for path in common_paths:
        if os.path.isfile(path) and os.access(path, os.X_OK):
            return path

    try:
        result = subprocess.run(["npm", "root", "-g"], capture_output=True, text=True)
        if result.returncode == 0:
            npm_path = os.path.join(result.stdout.strip(), ".bin", "claude")
            if os.path.isfile(npm_path):
                return npm_path
    except Exception:
        pass

    return None


def is_root():
    """Check if running as root/admin."""
    if IS_WINDOWS:
        try:
            import ctypes
            return ctypes.windll.shell32.IsUserAnAdmin() != 0
        except Exception:
            return False
    return os.getuid() == 0


def setup_settings():
    """Write ~/.claude/settings.json with bypass permissions as default mode.

    This is a belt-and-suspenders approach: even if the CLI flag fails,
    the settings file ensures bypass mode is the default.
    """
    config_dir = os.environ.get("CLAUDE_CONFIG_DIR", os.path.expanduser("~/.claude"))
    settings_path = os.path.join(config_dir, "settings.json")

    settings = {}
    if os.path.isfile(settings_path):
        try:
            with open(settings_path, "r") as f:
                settings = json.load(f)
        except (json.JSONDecodeError, IOError):
            pass

    changed = False

    # Set permissions.defaultMode to bypassPermissions
    if "permissions" not in settings:
        settings["permissions"] = {}
    if settings["permissions"].get("defaultMode") != "bypassPermissions":
        settings["permissions"]["defaultMode"] = "bypassPermissions"
        changed = True

    # Allow all tool patterns
    desired_allow = ["Bash(*)", "Edit", "Write", "Read", "Glob", "Grep",
                     "WebFetch(*)", "WebSearch(*)", "NotebookEdit", "Task(*)",
                     "Skill(*)"]
    if settings["permissions"].get("allow") != desired_allow:
        settings["permissions"]["allow"] = desired_allow
        changed = True

    # Skip the "are you sure?" trust dialog
    if settings.get("skipDangerousModePermissionPrompt") is not True:
        settings["skipDangerousModePermissionPrompt"] = True
        changed = True

    if changed:
        os.makedirs(config_dir, exist_ok=True)
        with open(settings_path, "w") as f:
            json.dump(settings, f, indent=2)
        print_status(f"Settings written: {settings_path}", GREEN)
    else:
        print_status(f"Settings OK: {settings_path}", GREEN)


def setup_environment():
    """Set environment variables needed for bypass as root."""
    env_set = []

    # IS_SANDBOX=1 unlocks --dangerously-skip-permissions for root
    if os.environ.get("IS_SANDBOX") != "1":
        os.environ["IS_SANDBOX"] = "1"
        env_set.append("IS_SANDBOX=1")

    # CLAUDE_CODE_BUBBLEWRAP=1 is the secondary check
    if os.environ.get("CLAUDE_CODE_BUBBLEWRAP") != "1":
        os.environ["CLAUDE_CODE_BUBBLEWRAP"] = "1"
        env_set.append("CLAUDE_CODE_BUBBLEWRAP=1")

    if env_set:
        print_status(f"Environment: {', '.join(env_set)}", GREEN)


def build_claude_cmd(claude_path, claude_args, bypass=True):
    """Build the full command to launch claude."""
    cmd = [claude_path]

    if bypass:
        # Only add if not already in user args
        if "--dangerously-skip-permissions" not in claude_args:
            cmd.append("--dangerously-skip-permissions")

    cmd.extend(claude_args)
    return cmd


def main():
    parser = argparse.ArgumentParser(
        description="claude-auto: Claude CLI wrapper with native permission bypass",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  claude-auto                          # Full interactive session, all permissions bypassed
  claude-auto "fix the bug"            # Interactive session with initial prompt
  claude-auto -p "fix the bug"         # One-shot prompt mode (non-interactive)
  claude-auto --no-bypass "fix bug"    # Disable bypass (fall back to normal claude)
  claude-auto --setup-only             # Just write settings, don't launch claude
  claude-auto -- --resume              # Pass flags directly to claude

Bypass method:
  1. Sets IS_SANDBOX=1 + CLAUDE_CODE_BUBBLEWRAP=1 (unlocks bypass for root)
  2. Passes --dangerously-skip-permissions to claude
  3. Writes ~/.claude/settings.json with bypassPermissions as default mode
        """
    )

    parser.add_argument(
        "--no-bypass", "-n",
        action="store_true",
        help="Disable permission bypass (run claude normally)"
    )

    parser.add_argument(
        "--setup-only",
        action="store_true",
        help="Only write settings.json and environment, don't launch claude"
    )

    parser.add_argument(
        "--no-settings",
        action="store_true",
        help="Skip writing settings.json (only use env vars + CLI flag)"
    )

    # Use parse_known_args so unknown flags pass through to claude
    args, claude_args = parser.parse_known_args()
    bypass = not args.no_bypass

    # Find claude
    claude_path = find_claude()
    if not claude_path:
        print_status("ERROR: Could not find 'claude' executable!", RED)
        print_status("Make sure claude CLI is installed and in your PATH", YELLOW)
        sys.exit(1)

    print_status(f"Found claude: {claude_path}")

    if bypass:
        print_status(f"BYPASS MODE: {GREEN}ON{RESET} (native --dangerously-skip-permissions)", GREEN)

        if is_root():
            print_status(f"Running as root - setting sandbox env vars", YELLOW)

        setup_environment()

        if not args.no_settings:
            setup_settings()
    else:
        print_status(f"BYPASS MODE: {RED}OFF{RESET} (normal claude)", YELLOW)

    if args.setup_only:
        print_status("Setup complete. Run 'claude-auto' to launch.", GREEN)
        sys.exit(0)

    # Build command
    cmd = build_claude_cmd(claude_path, claude_args, bypass)
    print_status(f"Launching: {' '.join(cmd)}")

    # Replace this process with claude (full interactive session)
    # os.execvpe gives claude direct access to the terminal - no PTY wrapper needed
    if IS_WINDOWS:
        # Windows doesn't support exec, use subprocess
        try:
            result = subprocess.run(cmd)
            sys.exit(result.returncode or 0)
        except KeyboardInterrupt:
            sys.exit(130)
    else:
        os.execvpe(cmd[0], cmd, os.environ)


if __name__ == "__main__":
    main()
