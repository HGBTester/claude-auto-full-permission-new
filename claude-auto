#!/usr/bin/env python3
"""
claude-auto: A cross-platform wrapper for claude CLI with auto-accept functionality.

When AUTO_ACCEPT is enabled, automatically selects the most aggressive option:
- Prefers "Yes, and don't ask again" over simple "Yes"
- Falls back to "Yes" if no "don't ask again" option exists
"""

import argparse
import os
import sys
import re
import shutil
import subprocess
import threading
import time
import platform

# Detect platform
IS_WINDOWS = platform.system() == "Windows"

# ANSI color codes (disabled on Windows CMD without colorama)
if IS_WINDOWS:
    try:
        import colorama
        colorama.init()
        GREEN = "\033[92m"
        YELLOW = "\033[93m"
        RED = "\033[91m"
        CYAN = "\033[96m"
        RESET = "\033[0m"
    except ImportError:
        GREEN = YELLOW = RED = CYAN = RESET = ""
else:
    GREEN = "\033[92m"
    YELLOW = "\033[93m"
    RED = "\033[91m"
    CYAN = "\033[96m"
    RESET = "\033[0m"


def print_status(msg, color=CYAN):
    """Print status message to stderr."""
    sys.stderr.write(f"{color}[claude-auto]{RESET} {msg}\n")
    sys.stderr.flush()


def find_claude():
    """Find claude executable in the system."""
    # Common names for claude executable
    names = ["claude", "claude.exe"] if IS_WINDOWS else ["claude"]

    # First try: use shutil.which (searches PATH)
    for name in names:
        path = shutil.which(name)
        if path:
            return path

    # Second try: common installation locations
    if IS_WINDOWS:
        common_paths = [
            os.path.expandvars(r"%LOCALAPPDATA%\Programs\claude\claude.exe"),
            os.path.expandvars(r"%APPDATA%\npm\claude.cmd"),
            os.path.expandvars(r"%APPDATA%\npm\claude"),
            os.path.expanduser(r"~\.claude\claude.exe"),
            r"C:\Program Files\claude\claude.exe",
            r"C:\Program Files (x86)\claude\claude.exe",
        ]
    else:
        common_paths = [
            "/usr/local/bin/claude",
            "/usr/bin/claude",
            os.path.expanduser("~/.local/bin/claude"),
            os.path.expanduser("~/.npm-global/bin/claude"),
            "/opt/claude/claude",
            os.path.expanduser("~/.claude/claude"),
        ]

    for path in common_paths:
        if os.path.isfile(path) and os.access(path, os.X_OK):
            return path

    # Third try: npm global
    try:
        if IS_WINDOWS:
            result = subprocess.run(["npm", "root", "-g"], capture_output=True, text=True)
        else:
            result = subprocess.run(["npm", "root", "-g"], capture_output=True, text=True)
        if result.returncode == 0:
            npm_path = os.path.join(result.stdout.strip(), ".bin", "claude")
            if os.path.isfile(npm_path):
                return npm_path
    except:
        pass

    return None


def analyze_prompt_options(text):
    """
    Analyze the prompt to determine the best option to select.
    Returns the key to send (arrow down + enter, or just enter, etc.)

    Strategy: Select the most aggressive option
    - "don't ask again" > "Yes" > anything else
    """
    # Check for "don't ask again" patterns (usually option 2)
    dont_ask_patterns = [
        r"don't ask again",
        r"don.t ask again",
        r"always allow",
        r"allow always",
        r"remember this",
        r"for this session",
    ]

    text_lower = text.lower()

    # If there's a "don't ask again" type option, we want to select it
    for pattern in dont_ask_patterns:
        if re.search(pattern, text_lower):
            # Usually option 2 is "don't ask again"
            # Send down arrow then enter to select option 2
            return "aggressive"

    # Default: just press enter (selects option 1 which is usually "Yes")
    return "default"


def is_plan_mode(text):
    """Check if claude is currently in plan mode."""
    plan_mode_patterns = [
        r'plan mode',
        r'\[plan\]',
        r'planning mode',
        r'Plan:',
        r'enter plan mode',
        r'exiting plan mode',
        r'plan file',
    ]
    text_lower = text.lower()
    for pattern in plan_mode_patterns:
        if re.search(pattern, text_lower):
            return True
    return False


class OutputMonitor:
    """Monitor output and auto-respond to prompts."""

    def __init__(self, auto_accept=True):
        self.auto_accept = auto_accept
        self.buffer = ""
        self.last_response_pos = 0
        self.lock = threading.Lock()
        self.responded = False
        self.response_cooldown = 0
        self.in_plan_mode = False

    def process_output(self, data, write_func):
        """Process output data and check for prompts."""
        with self.lock:
            self.buffer += data

            # Keep buffer manageable
            if len(self.buffer) > 10000:
                self.buffer = self.buffer[-5000:]
                self.last_response_pos = max(0, self.last_response_pos - 5000)

            # Check for plan mode status changes
            if is_plan_mode(data):
                if not self.in_plan_mode:
                    self.in_plan_mode = True
                    print_status(f"Plan mode detected - auto-accept {YELLOW}PAUSED{RESET}", YELLOW)

            # Detect exiting plan mode
            if self.in_plan_mode and re.search(r'(exiting plan|exit plan|plan complete|approved)', data.lower()):
                self.in_plan_mode = False
                print_status(f"Plan mode ended - auto-accept {GREEN}RESUMED{RESET}", GREEN)

            # Check for prompt in new content (only if NOT in plan mode)
            if self.auto_accept and not self.in_plan_mode and time.time() > self.response_cooldown:
                new_content = self.buffer[self.last_response_pos:]

                if re.search(r'Do you want to proceed\?', new_content, re.IGNORECASE):
                    # Determine best response
                    action = analyze_prompt_options(new_content)

                    # Delay to let prompt fully render
                    time.sleep(0.5)

                    if action == "aggressive":
                        # Send down arrow to move to option 2, then enter
                        # Down arrow is ESC [ B or just sending "2" might work
                        write_func(b"\x1b[B")  # Down arrow
                        time.sleep(0.1)
                        write_func(b"\r")      # Enter
                        print_status(f"Auto-selected: Option 2 (don't ask again)", GREEN)
                    else:
                        # Just press enter for option 1
                        write_func(b"\r")
                        print_status(f"Auto-selected: Option 1 (Yes)", GREEN)

                    self.last_response_pos = len(self.buffer)
                    self.response_cooldown = time.time() + 2  # 2 second cooldown


def run_claude_unix(claude_path, claude_args, auto_accept=True):
    """Run claude on Unix/Linux/Mac with PTY."""
    import pty
    import select
    import termios
    import tty

    cmd = [claude_path] + claude_args
    print_status(f"Running: {' '.join(cmd)}")

    # Create pseudo-terminal
    master_fd, slave_fd = pty.openpty()

    process = subprocess.Popen(
        cmd,
        stdin=slave_fd,
        stdout=slave_fd,
        stderr=slave_fd,
        close_fds=True
    )

    os.close(slave_fd)

    # Save terminal settings
    old_settings = None
    if sys.stdin.isatty():
        old_settings = termios.tcgetattr(sys.stdin)
        tty.setraw(sys.stdin.fileno())

    monitor = OutputMonitor(auto_accept)

    def write_to_master(data):
        os.write(master_fd, data)

    try:
        while True:
            rlist = [master_fd]
            if sys.stdin.isatty():
                rlist.append(sys.stdin)

            try:
                readable, _, _ = select.select(rlist, [], [], 0.1)
            except:
                break

            if process.poll() is not None:
                try:
                    remaining = os.read(master_fd, 4096)
                    if remaining:
                        sys.stdout.buffer.write(remaining)
                        sys.stdout.buffer.flush()
                except:
                    pass
                break

            if master_fd in readable:
                try:
                    data = os.read(master_fd, 4096)
                    if not data:
                        break

                    sys.stdout.buffer.write(data)
                    sys.stdout.buffer.flush()

                    try:
                        decoded = data.decode('utf-8', errors='replace')
                        monitor.process_output(decoded, write_to_master)
                    except:
                        pass
                except:
                    break

            if sys.stdin in readable:
                try:
                    user_input = os.read(sys.stdin.fileno(), 1024)
                    if user_input:
                        os.write(master_fd, user_input)
                        monitor.last_response_pos = len(monitor.buffer)
                except:
                    break

    except KeyboardInterrupt:
        process.terminate()
    finally:
        if old_settings:
            termios.tcsetattr(sys.stdin, termios.TCSADRAIN, old_settings)
        os.close(master_fd)

    return process.returncode or 0


def run_claude_windows(claude_path, claude_args, auto_accept=True):
    """Run claude on Windows."""
    import msvcrt

    cmd = [claude_path] + claude_args
    print_status(f"Running: {' '.join(cmd)}")

    # On Windows, we use subprocess with pipes and threads
    process = subprocess.Popen(
        cmd,
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        bufsize=0
    )

    monitor = OutputMonitor(auto_accept)
    stop_event = threading.Event()

    def write_to_stdin(data):
        try:
            process.stdin.write(data)
            process.stdin.flush()
        except:
            pass

    def read_output():
        """Read and display output from claude."""
        while not stop_event.is_set():
            try:
                data = process.stdout.read(1)
                if not data:
                    break

                sys.stdout.buffer.write(data)
                sys.stdout.buffer.flush()

                try:
                    decoded = data.decode('utf-8', errors='replace')
                    monitor.process_output(decoded, write_to_stdin)
                except:
                    pass
            except:
                break

    def read_input():
        """Read user input and send to claude."""
        while not stop_event.is_set() and process.poll() is None:
            try:
                if msvcrt.kbhit():
                    char = msvcrt.getch()
                    process.stdin.write(char)
                    process.stdin.flush()
                    monitor.last_response_pos = len(monitor.buffer)
                else:
                    time.sleep(0.05)
            except:
                break

    # Start threads
    output_thread = threading.Thread(target=read_output, daemon=True)
    input_thread = threading.Thread(target=read_input, daemon=True)

    output_thread.start()
    input_thread.start()

    try:
        process.wait()
    except KeyboardInterrupt:
        process.terminate()
    finally:
        stop_event.set()

    return process.returncode or 0


def main():
    parser = argparse.ArgumentParser(
        description="claude-auto: Cross-platform Claude CLI wrapper with auto-accept",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  claude-auto "fix the bug"           # Auto-accept ON (aggressive mode)
  claude-auto --no-auto "fix bug"     # Auto-accept OFF (manual mode)
  claude-auto -- --help               # Pass --help to claude

Auto-accept behavior:
  - Detects "Do you want to proceed?" prompts
  - Prefers "Yes, and don't ask again" (option 2) when available
  - Falls back to "Yes" (option 1) otherwise
        """
    )

    parser.add_argument(
        "--no-auto", "-n",
        action="store_true",
        help="Disable auto-accept (manual mode)"
    )

    parser.add_argument(
        "claude_args",
        nargs="*",
        help="Arguments to pass to claude"
    )

    args = parser.parse_args()
    auto_accept = not args.no_auto

    # Find claude
    claude_path = find_claude()
    if not claude_path:
        print_status("ERROR: Could not find 'claude' executable!", RED)
        print_status("Make sure claude CLI is installed and in your PATH", YELLOW)
        sys.exit(1)

    print_status(f"Found claude: {claude_path}")

    if auto_accept:
        print_status(f"AUTO-ACCEPT: {GREEN}ON{RESET} (aggressive mode - prefers 'don't ask again')", GREEN)
    else:
        print_status(f"AUTO-ACCEPT: {RED}OFF{RESET} (manual mode)", YELLOW)

    # Run with platform-specific implementation
    if IS_WINDOWS:
        exit_code = run_claude_windows(claude_path, args.claude_args, auto_accept)
    else:
        exit_code = run_claude_unix(claude_path, args.claude_args, auto_accept)

    sys.exit(exit_code)


if __name__ == "__main__":
    main()
