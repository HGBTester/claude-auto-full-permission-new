#!/usr/bin/env python3
"""
claude-auto: Cross-platform wrapper for Claude, Gemini, and Codex CLIs
that bypasses all permission prompts.

Supports all three AI coding CLIs with full permission bypass:
  - Claude Code  (--dangerously-skip-permissions)
  - Gemini CLI   (--yolo)
  - Codex CLI    (--dangerously-bypass-approvals-and-sandbox)

Features an interactive model selection menu and session loop.
"""

import argparse
import json
import os
import re
import sys
import shutil
import subprocess
import platform
import errno
import time
from datetime import datetime

IS_WINDOWS = platform.system() == "Windows"

if not IS_WINDOWS:
    import pty, tty, termios, select, signal, struct, fcntl

# ANSI colors
if IS_WINDOWS:
    try:
        import colorama
        colorama.init()
        GREEN = "\033[92m"
        YELLOW = "\033[93m"
        RED = "\033[91m"
        CYAN = "\033[96m"
        BOLD = "\033[1m"
        DIM = "\033[2m"
        RESET = "\033[0m"
        WHITE = "\033[97m"
    except ImportError:
        GREEN = YELLOW = RED = CYAN = BOLD = DIM = RESET = WHITE = ""
else:
    GREEN = "\033[92m"
    YELLOW = "\033[93m"
    RED = "\033[91m"
    CYAN = "\033[96m"
    BOLD = "\033[1m"
    DIM = "\033[2m"
    RESET = "\033[0m"
    WHITE = "\033[97m"

# Box-drawing characters (Unicode)
BOX_TL = "\u2554"  # ╔
BOX_TR = "\u2557"  # ╗
BOX_BL = "\u255a"  # ╚
BOX_BR = "\u255d"  # ╝
BOX_H  = "\u2550"  # ═
BOX_V  = "\u2551"  # ║
BOX_LT = "\u2560"  # ╠
BOX_RT = "\u2563"  # ╣

# Sticky header configuration
HEADER_ROWS = 3  # Rows reserved for the sticky prompt header

# ---------------------------------------------------------------------------
# Session capture & context handoff constants
# ---------------------------------------------------------------------------
SWITCH_KEY = b"\x1d"        # Ctrl+]
SWITCH_KEY_NAME = "Ctrl+]"  # for display

MAX_CONTEXT_CHARS = 50000
LOG_DIR = os.path.expanduser("~/.claude-auto/logs")

HANDOFF_TEMPLATE = """\
You are continuing a multi-model coding session. Below is the transcript of the \
previous session(s). Read it carefully and continue where it left off. Do NOT \
repeat work that was already completed.

<previous_session_transcript>
{transcript}
</previous_session_transcript>

Continue the task above. If the previous session ended mid-task, pick up from \
where it stopped. If it completed, ask the user what to do next."""

_ANSI_RE = re.compile(
    r"(\x1b\[[0-9;]*[A-Za-z]"       # CSI sequences
    r"|\x1b\][^\x07\x1b]*(?:\x07|\x1b\\)"  # OSC sequences
    r"|\x1b[()][0-9A-B]"            # charset selection
    r"|\x1b[=><%]"                   # misc mode escapes
    r"|\x1b\[[\?]?[0-9;]*[hlsr]"    # mode set/reset
    r")"
)

_ANSI_COLOR_RE = re.compile(r'\033\[[0-9;]*[A-Za-z]|\033\][^\x07]*\x07')

# ---------------------------------------------------------------------------
# Model definitions — all model-specific logic is driven from this dict
# ---------------------------------------------------------------------------
MODELS = {
    "claude": {
        "display_name": "Claude Code",
        "executables": ["claude.exe", "claude"] if IS_WINDOWS else ["claude"],
        "search_paths_unix": [
            "/usr/local/bin/claude",
            "/usr/bin/claude",
            "~/.local/bin/claude",
            "~/.npm-global/bin/claude",
            "/opt/claude/claude",
            "~/.claude/claude",
        ],
        "search_paths_windows": [
            r"%LOCALAPPDATA%\Programs\claude\claude.exe",
            r"%APPDATA%\npm\claude.cmd",
            r"%APPDATA%\npm\claude",
            r"~\.claude\claude.exe",
            r"C:\Program Files\claude\claude.exe",
            r"C:\Program Files (x86)\claude\claude.exe",
        ],
        "bypass_flag": "--dangerously-skip-permissions",
        "env_vars": {"IS_SANDBOX": "1", "CLAUDE_CODE_BUBBLEWRAP": "1"},
        "settings": {
            "config_dir_env": "CLAUDE_CONFIG_DIR",
            "config_dir_default": "~/.claude",
            "filename": "settings.json",
            "content": {
                "permissions": {
                    "defaultMode": "bypassPermissions",
                    "allow": [
                        "Bash(*)", "Edit", "Write", "Read", "Glob", "Grep",
                        "WebFetch(*)", "WebSearch(*)", "NotebookEdit",
                        "Task(*)", "Skill(*)",
                    ],
                },
                "skipDangerousModePermissionPrompt": True,
            },
        },
        "prompt_flag": "-p",
        "context_inject": "positional",
        "npm_package": "@anthropic-ai/claude-code",
    },
    "forked-claude": {
        "display_name": "Forked Claude",
        "executables": ["claude.exe", "claude"] if IS_WINDOWS else ["claude"],
        "search_paths_unix": [
            "/usr/local/bin/claude",
            "/usr/bin/claude",
            "~/.local/bin/claude",
            "~/.npm-global/bin/claude",
            "/opt/claude/claude",
            "~/.claude/claude",
        ],
        "search_paths_windows": [
            r"%LOCALAPPDATA%\Programs\claude\claude.exe",
            r"%APPDATA%\npm\claude.cmd",
            r"%APPDATA%\npm\claude",
            r"~\.claude\claude.exe",
            r"C:\Program Files\claude\claude.exe",
            r"C:\Program Files (x86)\claude\claude.exe",
        ],
        "bypass_flag": "--dangerously-skip-permissions",
        "env_vars": {
            "IS_SANDBOX": "1",
            "CLAUDE_CODE_BUBBLEWRAP": "1",
            "CLAUDE_CODE_SANDBOX_MODE": "1",
        },
        "settings": {
            "config_dir_env": "CLAUDE_CONFIG_DIR",
            "config_dir_default": "~/.claude",
            "filename": "settings.json",
            "content": {
                "permissions": {
                    "defaultMode": "bypassPermissions",
                    "allow": [
                        "Bash(*)", "Edit", "Write", "Read", "Glob", "Grep",
                        "WebFetch(*)", "WebSearch(*)", "NotebookEdit",
                        "Task(*)", "Skill(*)", "EnterPlanMode",
                        "EnterWorktree", "AskUserQuestion",
                    ],
                },
                "skipDangerousModePermissionPrompt": True,
            },
        },
        "prompt_flag": "-p",
        "context_inject": "positional",
        "npm_package": "@anthropic-ai/claude-code",
    },
    "gemini": {
        "display_name": "Gemini CLI",
        "executables": ["gemini.exe", "gemini"] if IS_WINDOWS else ["gemini"],
        "search_paths_unix": [
            "/usr/local/bin/gemini",
            "/usr/bin/gemini",
            "~/.local/bin/gemini",
            "~/.npm-global/bin/gemini",
        ],
        "search_paths_windows": [
            r"%APPDATA%\npm\gemini.cmd",
            r"%APPDATA%\npm\gemini",
        ],
        "bypass_flag": "--yolo",
        "env_vars": {},
        "settings": None,
        "prompt_flag": None,
        "context_inject": "flag_interactive",
        "npm_package": "@google/gemini-cli",
    },
    "codex": {
        "display_name": "Codex CLI",
        "executables": ["codex.exe", "codex"] if IS_WINDOWS else ["codex"],
        "search_paths_unix": [
            "/usr/local/bin/codex",
            "/usr/bin/codex",
            "~/.local/bin/codex",
            "~/.npm-global/bin/codex",
        ],
        "search_paths_windows": [
            r"%APPDATA%\npm\codex.cmd",
            r"%APPDATA%\npm\codex",
        ],
        "bypass_flag": "--dangerously-bypass-approvals-and-sandbox",
        "env_vars": {},
        "settings": None,
        "prompt_flag": "-p",
        "context_inject": "positional",
        "npm_package": "@openai/codex",
    },
}


# ---------------------------------------------------------------------------
# Terminal & display helpers
# ---------------------------------------------------------------------------

def get_term_size():
    """Get terminal (rows, cols), defaulting to (24, 80)."""
    try:
        size = os.get_terminal_size()
        return size.lines, size.columns
    except (OSError, ValueError):
        return 24, 80


def _visible_len(s):
    """Visible length of a string, excluding ANSI escape sequences."""
    return len(_ANSI_COLOR_RE.sub('', s))


def print_status(msg, color=CYAN):
    sys.stderr.write(f"{color}[claude-auto]{RESET} {msg}\n")
    sys.stderr.flush()


def set_terminal_title(text):
    """Set terminal window/tab title via OSC escape sequence."""
    try:
        os.write(sys.stdout.fileno(), f"\033]2;claude-auto: {text}\007".encode())
    except OSError:
        pass


def draw_full_width_box(title, body_lines, border_color=CYAN, title_color=None):
    """Draw a full-width Unicode box to stdout."""
    _, cols = get_term_size()
    if title_color is None:
        title_color = f"{BOLD}{WHITE}"
    inner = max(cols - 2, 20)

    # Top border with embedded title
    if title:
        title_text = f" {title} "
        fill = inner - len(title_text) - 1
        if fill < 0:
            title_text = title_text[:inner + 1]
            fill = 0
        top = (
            f"{border_color}{BOX_TL}{BOX_H}"
            f"{title_color}{title_text}"
            f"{border_color}{BOX_H * fill}{BOX_TR}{RESET}"
        )
    else:
        top = f"{border_color}{BOX_TL}{BOX_H * inner}{BOX_TR}{RESET}"

    bot = f"{border_color}{BOX_BL}{BOX_H * inner}{BOX_BR}{RESET}"
    sep = f"{border_color}{BOX_LT}{BOX_H * inner}{BOX_RT}{RESET}"

    output = [top]
    # Max visible chars for body content: inner width minus the leading space
    max_content_vlen = inner - 1
    for line in body_lines:
        if line == "---":
            output.append(sep)
            continue
        vlen = _visible_len(line)
        # Truncate lines that would overflow the box
        if vlen > max_content_vlen:
            # Strip ANSI, truncate visible text, add ellipsis
            plain = _ANSI_COLOR_RE.sub('', line)
            line = plain[:max_content_vlen - 3] + "..."
            vlen = len(line)
        pad_right = inner - 1 - vlen
        if pad_right < 0:
            pad_right = 0
        output.append(
            f"{border_color}{BOX_V}{RESET} {line}"
            f"{' ' * pad_right}"
            f"{border_color}{BOX_V}{RESET}"
        )
    output.append(bot)

    print("\n".join(output))


def build_header_bytes(prompt_text, model_name, cols):
    """Build the 3-line sticky header as raw bytes for terminal output."""
    inner = max(cols - 2, 20)

    if not prompt_text:
        prompt_text = "Waiting for input..."

    # Top line with model name badge
    badge = f" {model_name} "
    fill = inner - len(badge) - 1
    if fill < 0:
        badge = badge[:inner + 1]
        fill = 0
    top = f"{BOX_TL}{BOX_H}{badge}{BOX_H * fill}{BOX_TR}"

    # Middle line with current prompt
    content = f" WORKING ON: {prompt_text}"
    if len(content) > inner:
        content = content[:inner - 3] + "..."
    content = content.ljust(inner)
    mid = f"{BOX_V}{content}{BOX_V}"

    # Bottom line
    bot = f"{BOX_BL}{BOX_H * inner}{BOX_BR}"

    # Compose with colors: yellow border, white-on-blue content
    Y = "\033[1;93m"   # bold bright yellow
    W = "\033[1;97;44m" # bold white on blue background
    R = "\033[0m"

    header = (
        f"\033[s"                        # save cursor
        f"\033[1;1H\033[2K{Y}{top}{R}"   # row 1: erase line, then top border
        f"\033[2;1H\033[2K{W}{mid}{R}"   # row 2: erase line, then prompt content
        f"\033[3;1H\033[2K{Y}{bot}{R}"   # row 3: erase line, then bottom border
        f"\033[u"                        # restore cursor
    )
    return header.encode()


# ---------------------------------------------------------------------------
# Generic functions (replace old Claude-specific ones)
# ---------------------------------------------------------------------------

def find_executable(model_key):
    """Find the executable for a given model."""
    model = MODELS[model_key]

    # 1) Check PATH via shutil.which
    for name in model["executables"]:
        path = shutil.which(name)
        if path:
            return path

    # 2) Check common installation paths
    if IS_WINDOWS:
        search_paths = model.get("search_paths_windows", [])
    else:
        search_paths = model.get("search_paths_unix", [])

    for p in search_paths:
        expanded = os.path.expandvars(os.path.expanduser(p))
        if os.path.isfile(expanded) and os.access(expanded, os.X_OK):
            return expanded

    # 3) Try npm global bin
    try:
        result = subprocess.run(
            ["npm", "root", "-g"], capture_output=True, text=True
        )
        if result.returncode == 0:
            exe_name = model["executables"][-1]
            npm_path = os.path.join(result.stdout.strip(), ".bin", exe_name)
            if os.path.isfile(npm_path):
                return npm_path
    except Exception:
        pass

    return None


def detect_installed_models():
    """Return dict of {model_key: executable_path} for all found models."""
    found = {}
    for key in MODELS:
        path = find_executable(key)
        if path:
            found[key] = path
    return found


def is_root():
    """Check if running as root/admin."""
    if IS_WINDOWS:
        try:
            import ctypes
            return ctypes.windll.shell32.IsUserAnAdmin() != 0
        except Exception:
            return False
    return os.getuid() == 0


def setup_environment(model_key):
    """Set environment variables needed for bypass (model-specific)."""
    model = MODELS[model_key]
    env_vars = model.get("env_vars", {})
    if not env_vars:
        return

    env_set = []
    for var, val in env_vars.items():
        if os.environ.get(var) != val:
            os.environ[var] = val
            env_set.append(f"{var}={val}")

    if env_set:
        print_status(f"Environment: {', '.join(env_set)}", GREEN)


def setup_settings(model_key):
    """Write config file with bypass permissions if the model needs it."""
    model = MODELS[model_key]
    settings_spec = model.get("settings")
    if not settings_spec:
        return

    config_dir = os.environ.get(
        settings_spec["config_dir_env"],
        os.path.expanduser(settings_spec["config_dir_default"]),
    )
    settings_path = os.path.join(config_dir, settings_spec["filename"])

    # Read existing
    settings = {}
    if os.path.isfile(settings_path):
        try:
            with open(settings_path, "r") as f:
                settings = json.load(f)
        except (json.JSONDecodeError, IOError):
            pass

    desired = settings_spec["content"]
    changed = False

    for key, value in desired.items():
        if isinstance(value, dict):
            if key not in settings:
                settings[key] = {}
            for subkey, subval in value.items():
                if settings[key].get(subkey) != subval:
                    settings[key][subkey] = subval
                    changed = True
        else:
            if settings.get(key) != value:
                settings[key] = value
                changed = True

    if changed:
        os.makedirs(config_dir, exist_ok=True)
        with open(settings_path, "w") as f:
            json.dump(settings, f, indent=2)
        print_status(f"Settings written: {settings_path}", GREEN)
    else:
        print_status(f"Settings OK: {settings_path}", GREEN)


def build_cmd(model_key, exe_path, extra_args, bypass=True, context_prompt=None):
    """Build the full command to launch a model CLI."""
    model = MODELS[model_key]
    cmd = [exe_path]

    if bypass and model["bypass_flag"]:
        if model["bypass_flag"] not in extra_args:
            cmd.append(model["bypass_flag"])

    cmd.extend(extra_args)

    if context_prompt:
        mode = model.get("context_inject", "positional")
        if mode == "flag_interactive":
            cmd.extend(["-i", context_prompt])
        else:
            cmd.append(context_prompt)

    return cmd


# ---------------------------------------------------------------------------
# PTY session capture with sticky header (Unix only)
# ---------------------------------------------------------------------------

def run_session_pty(cmd, model_name="AI Agent", initial_prompt=""):
    """Run cmd under a PTY, proxying I/O and capturing child output.

    Features a sticky header at the top showing the current prompt,
    scroll region to protect the header, and terminal title updates.

    Returns (exit_code, captured_bytes, switch_requested).
    """
    captured = bytearray()
    switch_requested = False

    pid, master_fd = pty.fork()
    if pid == 0:
        os.execvp(cmd[0], cmd)
        os._exit(127)

    old_attrs = termios.tcgetattr(sys.stdin.fileno())

    # Terminal state
    rows, cols = get_term_size()
    child_rows = max(rows - HEADER_ROWS, 10)

    # Header state
    current_prompt = initial_prompt
    stdin_line_buf = bytearray()
    alt_screen_active = False
    last_header_draw = 0.0
    HEADER_REDRAW_INTERVAL = 2.0

    def _sigwinch(signum, frame):
        """Forward terminal resize to child PTY and redraw header."""
        nonlocal rows, cols, child_rows
        try:
            rows, cols = get_term_size()
            child_rows = max(rows - HEADER_ROWS, 10)
            winsize = struct.pack("HHHH", child_rows, cols, 0, 0)
            fcntl.ioctl(master_fd, termios.TIOCSWINSZ, winsize)
            os.kill(pid, signal.SIGWINCH)
            if not alt_screen_active:
                os.write(
                    sys.stdout.fileno(),
                    f"\033[{HEADER_ROWS + 1};{rows}r".encode(),
                )
                header = build_header_bytes(current_prompt, model_name, cols)
                os.write(sys.stdout.fileno(), header)
        except (OSError, ValueError):
            pass

    prev_handler = signal.signal(signal.SIGWINCH, _sigwinch)

    # Set child PTY size (reduced by header rows)
    try:
        winsize = struct.pack("HHHH", child_rows, cols, 0, 0)
        fcntl.ioctl(master_fd, termios.TIOCSWINSZ, winsize)
    except (OSError, ValueError):
        pass

    # Clear screen, draw initial header and set scroll region
    try:
        # Clear screen first to prevent residual content from previous renders
        os.write(sys.stdout.fileno(), b"\033[2J\033[H")
        header = build_header_bytes(current_prompt, model_name, cols)
        os.write(sys.stdout.fileno(), header)
        # Set scroll region: rows below header to bottom of terminal
        os.write(
            sys.stdout.fileno(),
            f"\033[{HEADER_ROWS + 1};{rows}r".encode(),
        )
        # Move cursor into the scroll region
        os.write(
            sys.stdout.fileno(),
            f"\033[{HEADER_ROWS + 1};1H".encode(),
        )
        set_terminal_title(current_prompt or model_name)
        last_header_draw = time.monotonic()
    except (OSError, ValueError):
        pass

    try:
        tty.setraw(sys.stdin.fileno())

        while True:
            try:
                ready, _, _ = select.select(
                    [sys.stdin, master_fd], [], [], 0.1
                )
            except (select.error, OSError) as e:
                if getattr(e, "errno", None) == errno.EINTR or (
                    isinstance(e, OSError) and e.errno == errno.EINTR
                ):
                    continue
                raise

            now = time.monotonic()

            # Periodic header redraw during idle (non-alt-screen)
            if not ready and not alt_screen_active:
                if (now - last_header_draw) >= HEADER_REDRAW_INTERVAL:
                    try:
                        header = build_header_bytes(
                            current_prompt, model_name, cols
                        )
                        os.write(sys.stdout.fileno(), header)
                        last_header_draw = now
                    except OSError:
                        pass

            if master_fd in ready:
                try:
                    data = os.read(master_fd, 4096)
                except OSError:
                    break
                if not data:
                    break

                # Detect alternate screen buffer enter/exit
                if b'\033[?1049h' in data or b'\033[?47h' in data:
                    alt_screen_active = True
                if b'\033[?1049l' in data or b'\033[?47l' in data:
                    alt_screen_active = False
                    try:
                        rows, cols = get_term_size()
                        os.write(
                            sys.stdout.fileno(),
                            f"\033[{HEADER_ROWS + 1};{rows}r".encode(),
                        )
                        header = build_header_bytes(
                            current_prompt, model_name, cols
                        )
                        os.write(sys.stdout.fileno(), header)
                        last_header_draw = now
                    except OSError:
                        pass

                captured.extend(data)
                os.write(sys.stdout.fileno(), data)

            if sys.stdin in ready:
                try:
                    data = os.read(sys.stdin.fileno(), 4096)
                except OSError:
                    break
                if not data:
                    break

                # Check for model switch key
                if SWITCH_KEY in data:
                    switch_requested = True
                    termios.tcsetattr(
                        sys.stdin.fileno(), termios.TCSAFLUSH, old_attrs
                    )
                    # Restore full scroll region and clear header
                    try:
                        os.write(
                            sys.stdout.fileno(),
                            f"\033[1;{rows}r".encode(),
                        )
                        for row in range(1, HEADER_ROWS + 1):
                            os.write(
                                sys.stdout.fileno(),
                                f"\033[{row};1H\033[2K".encode(),
                            )
                    except OSError:
                        pass
                    os.write(sys.stdout.fileno(), b"\r\n")
                    print_status(
                        f"Switch triggered ({SWITCH_KEY_NAME}) "
                        f"— ending session...",
                        YELLOW,
                    )
                    try:
                        os.kill(pid, signal.SIGTERM)
                    except OSError:
                        pass
                    for _ in range(20):
                        pid_result, _ = os.waitpid(pid, os.WNOHANG)
                        if pid_result != 0:
                            break
                        time.sleep(0.1)
                    else:
                        try:
                            os.kill(pid, signal.SIGKILL)
                        except OSError:
                            pass
                    break

                # Track user input to detect prompt submissions
                for b_val in data:
                    if b_val in (0x0d, 0x0a):  # Enter
                        if stdin_line_buf:
                            new_prompt = stdin_line_buf.decode(
                                'utf-8', errors='replace'
                            ).strip()
                            if new_prompt and len(new_prompt) > 2:
                                current_prompt = new_prompt
                                set_terminal_title(current_prompt)
                                if not alt_screen_active:
                                    try:
                                        header = build_header_bytes(
                                            current_prompt, model_name, cols
                                        )
                                        os.write(
                                            sys.stdout.fileno(), header
                                        )
                                        last_header_draw = now
                                    except OSError:
                                        pass
                            stdin_line_buf.clear()
                    elif b_val in (0x7f, 0x08):  # Backspace / DEL
                        if stdin_line_buf:
                            stdin_line_buf.pop()
                    elif b_val == 0x03:  # Ctrl+C — clear input buffer
                        stdin_line_buf.clear()
                    elif b_val >= 0x20:  # Printable character
                        stdin_line_buf.append(b_val)

                os.write(master_fd, data)
    finally:
        if not switch_requested:
            termios.tcsetattr(
                sys.stdin.fileno(), termios.TCSADRAIN, old_attrs
            )
        signal.signal(signal.SIGWINCH, prev_handler)
        # Restore full scroll region, clear header area, and clear terminal title
        try:
            rows, _ = get_term_size()
            os.write(sys.stdout.fileno(), f"\033[1;{rows}r".encode())
            # Clear the sticky header rows to prevent residual text
            for row in range(1, HEADER_ROWS + 1):
                os.write(
                    sys.stdout.fileno(),
                    f"\033[{row};1H\033[2K".encode(),
                )
            # Move cursor below the cleared header area
            os.write(
                sys.stdout.fileno(),
                f"\033[{HEADER_ROWS + 1};1H".encode(),
            )
            os.write(sys.stdout.fileno(), b"\033]2;\007")
        except OSError:
            pass

    # Drain remaining output
    while True:
        try:
            ready, _, _ = select.select([master_fd], [], [], 0.05)
            if not ready:
                break
            data = os.read(master_fd, 4096)
            if not data:
                break
            captured.extend(data)
        except OSError:
            break

    try:
        os.close(master_fd)
    except OSError:
        pass

    try:
        _, status = os.waitpid(pid, 0)
        exit_code = os.WEXITSTATUS(status) if os.WIFEXITED(status) else 1
    except ChildProcessError:
        exit_code = 0

    return exit_code, bytes(captured), switch_requested


# ---------------------------------------------------------------------------
# ANSI stripping & context management
# ---------------------------------------------------------------------------

def strip_ansi(raw_bytes):
    """Convert captured PTY bytes to clean text."""
    try:
        text = raw_bytes.decode("utf-8", errors="replace")
    except Exception:
        text = raw_bytes.decode("latin-1", errors="replace")
    text = _ANSI_RE.sub("", text)
    text = re.sub(r"[\x00-\x08\x0b\x0c\x0e-\x1f\x7f]", "", text)
    text = text.replace("\r", "")
    text = re.sub(r"\n{3,}", "\n\n", text)
    return text.strip()


def truncate_context(text, max_chars=MAX_CONTEXT_CHARS):
    """Tail-truncate text to max_chars, breaking at a session boundary if possible."""
    if len(text) <= max_chars:
        return text
    truncated = text[-max_chars:]
    marker = truncated.find("\n--- Session ")
    if marker != -1 and marker < len(truncated) // 2:
        truncated = truncated[marker + 1:]
    else:
        nl = truncated.find("\n")
        if nl != -1 and nl < 200:
            truncated = truncated[nl + 1:]
    return "[...truncated...]\n" + truncated


def format_handoff_prompt(accumulated_context):
    """Wrap accumulated transcript in the handoff template."""
    trimmed = truncate_context(accumulated_context)
    return HANDOFF_TEMPLATE.format(transcript=trimmed)


def save_session_log(model_key, text, session_num, log_dir=None):
    """Save session transcript to disk. Returns the log path or None."""
    if not text:
        return None
    log_dir = log_dir or LOG_DIR
    try:
        os.makedirs(log_dir, exist_ok=True)
        ts = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"{ts}_s{session_num:02d}_{model_key}.log"
        path = os.path.join(log_dir, filename)
        with open(path, "w", encoding="utf-8") as f:
            f.write(text)
        return path
    except OSError as e:
        print_status(f"Warning: could not save log: {e}", YELLOW)
        return None


# ---------------------------------------------------------------------------
# Interactive model selection menu (full-width boxes)
# ---------------------------------------------------------------------------

def show_model_menu(installed):
    """Show interactive model picker. Returns chosen model_key or None to quit."""
    keys = list(installed.keys())

    body = [""]
    for i, key in enumerate(keys, 1):
        model = MODELS[key]
        body.append(
            f"  {BOLD}{CYAN}{i}{RESET})  "
            f"{BOLD}{model['display_name']:<15}{RESET} "
            f"{DIM}({key}){RESET}"
        )
    body.append("")
    body.append("---")
    body.append(f"  {BOLD}{RED}q{RESET})  Quit")
    body.append("")

    print()
    draw_full_width_box(
        "claude-auto \u2014 AI Coding CLI Launcher",
        body,
        border_color=CYAN,
    )
    print()

    while True:
        try:
            choice = input(
                f"  {CYAN}{BOLD}\u276f{RESET} Select model "
                f"[{BOLD}1-{len(keys)}{RESET}/q]: "
            ).strip().lower()
        except (EOFError, KeyboardInterrupt):
            print()
            return None

        if choice in ("q", "quit", "exit"):
            return None

        if choice.isdigit():
            idx = int(choice) - 1
            if 0 <= idx < len(keys):
                return keys[idx]

        if choice in installed:
            return choice

        print(f"  {RED}Invalid choice. Try again.{RESET}")


def show_post_session_menu(installed, has_context):
    """Show model picker after a session ends, with context carry option.

    Returns (model_key, carry_context) or (None, False) to quit.
    """
    keys = list(installed.keys())

    body = [""]
    for i, key in enumerate(keys, 1):
        model = MODELS[key]
        body.append(
            f"  {BOLD}{CYAN}{i}{RESET})  "
            f"{BOLD}{model['display_name']:<15}{RESET} "
            f"{DIM}({key}){RESET}"
        )
    body.append("")
    body.append("---")
    body.append(f"  {BOLD}{RED}q{RESET})  Quit")
    body.append("")

    print()
    draw_full_width_box(
        "Session ended \u2014 pick next model or quit",
        body,
        border_color=YELLOW,
    )
    print()

    while True:
        try:
            choice = input(
                f"  {YELLOW}{BOLD}\u276f{RESET} Select model "
                f"[{BOLD}1-{len(keys)}{RESET}/q]: "
            ).strip().lower()
        except (EOFError, KeyboardInterrupt):
            print()
            return None, False

        if choice in ("q", "quit", "exit"):
            return None, False

        chosen_key = None

        if choice.isdigit():
            idx = int(choice) - 1
            if 0 <= idx < len(keys):
                chosen_key = keys[idx]
        elif choice in installed:
            chosen_key = choice

        if chosen_key is None:
            print(f"  {RED}Invalid choice. Try again.{RESET}")
            continue

        carry = False
        if has_context:
            try:
                answer = input(
                    f"  Carry context from previous session? "
                    f"[{GREEN}Y{RESET}/n]: "
                ).strip().lower()
            except (EOFError, KeyboardInterrupt):
                print()
                return None, False
            carry = answer != "n"

        return chosen_key, carry


def list_models():
    """Print all models and their install status, then exit."""
    body = [""]
    for key, model in MODELS.items():
        path = find_executable(key)
        if path:
            status = f"{GREEN}{BOLD}FOUND{RESET}  {DIM}{path}{RESET}"
        else:
            status = f"{RED}{BOLD}NOT FOUND{RESET}"
        body.append(
            f"  {model['display_name']:<15} {DIM}({key:<7}){RESET}  {status}"
        )
    body.append("")

    print()
    draw_full_width_box("Supported Models", body, border_color=CYAN)
    print()


# ---------------------------------------------------------------------------
# Main
# ---------------------------------------------------------------------------

def main():
    parser = argparse.ArgumentParser(
        description="claude-auto: Multi-model AI CLI wrapper with permission bypass",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  claude-auto                          # Interactive model picker (if multiple installed)
  claude-auto --model claude           # Launch Claude with bypass, exit when done
  claude-auto -M gemini                # Launch Gemini with --yolo
  claude-auto -M codex                 # Launch Codex with bypass
  claude-auto --list-models            # Show installed models
  claude-auto --no-bypass -M gemini    # Launch Gemini without --yolo
  claude-auto --no-loop                # Exit after first session (no menu loop)
  claude-auto --setup-only             # Just write settings, don't launch
  claude-auto --no-capture             # Disable PTY capture (plain subprocess)
  claude-auto --no-context             # Disable context handoff between sessions
  claude-auto --log-dir /tmp/logs      # Custom session log directory

Bypass mechanisms:
  Claude:  IS_SANDBOX=1, CLAUDE_CODE_BUBBLEWRAP=1, --dangerously-skip-permissions, settings.json
  Gemini:  --yolo
  Codex:   --dangerously-bypass-approvals-and-sandbox
        """,
    )

    parser.add_argument(
        "--model", "-M",
        choices=list(MODELS.keys()),
        help="Select model directly (claude, gemini, codex) — skip menu, no loop",
    )

    parser.add_argument(
        "--list-models", "-L",
        action="store_true",
        help="Show installed models and exit",
    )

    parser.add_argument(
        "--no-loop",
        action="store_true",
        help="Exit after session ends (don't show model menu again)",
    )

    parser.add_argument(
        "--no-bypass", "-n",
        action="store_true",
        help="Disable permission bypass (run model CLI normally)",
    )

    parser.add_argument(
        "--setup-only",
        action="store_true",
        help="Only write settings/environment, don't launch any CLI",
    )

    parser.add_argument(
        "--no-settings",
        action="store_true",
        help="Skip writing settings.json (only use env vars + CLI flag)",
    )

    parser.add_argument(
        "--no-capture",
        action="store_true",
        help="Disable PTY capture (plain subprocess, no context handoff)",
    )

    parser.add_argument(
        "--no-context",
        action="store_true",
        help="Disable context handoff between sessions (still saves logs)",
    )

    parser.add_argument(
        "--log-dir",
        metavar="DIR",
        help="Custom directory for session logs (default: ~/.claude-auto/logs)",
    )

    args, passthrough_args = parser.parse_known_args()
    bypass = not args.no_bypass
    capture = not args.no_capture and not IS_WINDOWS
    enable_context = not args.no_context and capture
    log_dir = args.log_dir

    # --list-models: show and exit
    if args.list_models:
        list_models()
        sys.exit(0)

    # Detect installed models
    installed = detect_installed_models()

    if not installed:
        print_status("ERROR: No supported CLI found (claude, gemini, codex)!", RED)
        print_status("Install at least one:", YELLOW)
        for key, model in MODELS.items():
            print_status(f"  npm install -g {model['npm_package']}", YELLOW)
        sys.exit(1)

    # --setup-only: configure all installed models and exit
    if args.setup_only:
        for key in installed:
            print_status(f"Setting up {MODELS[key]['display_name']}...", CYAN)
            if bypass:
                setup_environment(key)
                if not args.no_settings:
                    setup_settings(key)
        print_status("Setup complete. Run 'claude-auto' to launch.", GREEN)
        sys.exit(0)

    accumulated_context = ""
    session_num = 0

    if args.model:
        if args.model not in installed:
            print_status(
                f"ERROR: {MODELS[args.model]['display_name']} not found!", RED
            )
            print_status("Run 'claude-auto --list-models' to see installed models", YELLOW)
            sys.exit(1)
        session_num += 1
        run_session(args.model, installed[args.model], passthrough_args,
                    bypass, args.no_settings, capture=capture,
                    log_dir=log_dir, session_num=session_num,
                    show_switch_hint=False)
        sys.exit(0)

    if len(installed) == 1 and args.no_loop:
        key = next(iter(installed))
        session_num += 1
        run_session(key, installed[key], passthrough_args, bypass,
                    args.no_settings, capture=capture, log_dir=log_dir,
                    session_num=session_num, show_switch_hint=False)
        sys.exit(0)

    # Interactive menu loop
    model_key = None
    if len(installed) == 1:
        model_key = next(iter(installed))
    else:
        model_key = show_model_menu(installed)

    show_hint = not args.no_loop

    while model_key is not None:
        session_num += 1

        context_prompt = None
        if enable_context and accumulated_context:
            context_prompt = format_handoff_prompt(accumulated_context)

        exit_code, captured, switch_requested = run_session(
            model_key, installed[model_key], passthrough_args, bypass,
            args.no_settings, context_prompt=context_prompt, capture=capture,
            log_dir=log_dir, session_num=session_num,
            show_switch_hint=show_hint,
        )

        if captured and enable_context:
            accumulated_context += (
                f"--- Session {session_num}: {model_key} ---\n"
                f"{captured}\n"
                f"--- End Session {session_num} ---\n\n"
            )

        if switch_requested:
            print_status(f"Switch triggered ({SWITCH_KEY_NAME}) — pick next model", CYAN)
            model_key = show_model_menu(installed)
            if model_key is None:
                print_status("Goodbye!", GREEN)
                break
            if accumulated_context and enable_context:
                ctx_len = len(accumulated_context)
                print_status(
                    f"Carrying {ctx_len:,} chars of context to next session.",
                    GREEN,
                )
            continue

        if args.no_loop:
            break

        has_context = bool(accumulated_context) and enable_context
        model_key, carry = show_post_session_menu(installed, has_context)

        if model_key is None:
            print_status("Goodbye!", GREEN)
            break

        if not carry:
            accumulated_context = ""
            print_status("Context cleared — starting fresh.", CYAN)
        else:
            ctx_len = len(accumulated_context)
            print_status(
                f"Carrying {ctx_len:,} chars of context to next session.",
                GREEN,
            )


def run_session(model_key, exe_path, extra_args, bypass, no_settings,
                 context_prompt=None, capture=True, log_dir=None,
                 session_num=1, show_switch_hint=False):
    """Set up and run a single CLI session.

    Returns (exit_code, captured_text_or_empty_string, switch_requested).
    """
    model = MODELS[model_key]

    if bypass:
        if is_root() and model["env_vars"]:
            print_status("Running as root — setting sandbox env vars", YELLOW)
        setup_environment(model_key)
        if not no_settings:
            setup_settings(model_key)

    # Determine initial prompt for sticky header
    initial_prompt = ""
    if context_prompt:
        initial_prompt = "Continuing from previous session"
    for i, arg in enumerate(extra_args):
        if arg in ("-p", "--prompt") and i + 1 < len(extra_args):
            initial_prompt = extra_args[i + 1]
            break

    cmd = build_cmd(model_key, exe_path, extra_args, bypass,
                    context_prompt=context_prompt)

    # Display session info in a nice box
    body = []
    body.append(f"  {DIM}Path:{RESET}     {exe_path}")
    if bypass:
        body.append(
            f"  {DIM}Bypass:{RESET}   "
            f"{GREEN}{BOLD}ON{RESET} "
            f"{DIM}({model['bypass_flag']}){RESET}"
        )
    else:
        body.append(f"  {DIM}Bypass:{RESET}   {RED}{BOLD}OFF{RESET}")
    body.append(f"  {DIM}Session:{RESET}  #{session_num}")
    if context_prompt:
        body.append(
            f"  {DIM}Context:{RESET}  "
            f"{CYAN}Injecting from previous session{RESET}"
        )
    if initial_prompt and not context_prompt:
        display_prompt = initial_prompt[:60]
        if len(initial_prompt) > 60:
            display_prompt += "..."
        body.append(f"  {DIM}Prompt:{RESET}   {WHITE}{display_prompt}{RESET}")
    if show_switch_hint:
        body.append(
            f"  {DIM}Tip:{RESET}      "
            f"Press {BOLD}{SWITCH_KEY_NAME}{RESET} to switch models"
        )

    print()
    draw_full_width_box(
        f" {model['display_name']} ",
        body,
        border_color=GREEN,
        title_color=f"{BOLD}{GREEN}",
    )
    print()

    captured_text = ""
    switch_requested = False

    if capture and not IS_WINDOWS:
        try:
            exit_code, raw, switch_requested = run_session_pty(
                cmd,
                model_name=model['display_name'],
                initial_prompt=initial_prompt,
            )
            captured_text = strip_ansi(raw)
        except Exception as e:
            print_status(
                f"PTY capture failed ({e}), falling back to subprocess",
                YELLOW,
            )
            try:
                result = subprocess.run(cmd)
                exit_code = result.returncode or 0
            except KeyboardInterrupt:
                exit_code = 130
    else:
        try:
            result = subprocess.run(cmd)
            exit_code = result.returncode or 0
        except KeyboardInterrupt:
            exit_code = 130

    if captured_text:
        log_path = save_session_log(model_key, captured_text, session_num,
                                    log_dir=log_dir)
        if log_path:
            print_status(f"Session log saved: {log_path}", GREEN)

    return exit_code, captured_text, switch_requested


if __name__ == "__main__":
    main()
